// Generated by dts-bundle v0.7.3

declare module 'blocklike' {
    import Stage from "blocklike/stage";
    import Backdrop from "blocklike/backdrop";
    import Sprite from "blocklike/sprite";
    import Costume from "blocklike/costume";
    export { Stage, Backdrop, Sprite, Costume };
}

declare module 'blocklike/stage' {
    /**
      * Class representing a Stage.
      * @extends Entity
      *
      * @example
      * let stage = new blockLike.Stage();
      *
      * @example
      * let stage = new blockLike.Stage({
      *   width: 600,
      *   height: 400,
      *   pace: 16,
      *   sensing: true,
      *   parent: document.getElementById('stage-wrap'),
      *   backdrop: new blockLike.Backdrop({color: '#FFB6C1'})
      * });
      */
    export default class Stage extends Entity {
        /**
         * constructor - Creates a Stage.
         *
         * @param {object} options - Options for the Stage.
         * @param {number} options.width - The stage width in pixels. Default is full window.
         * @param {number} options.height - The stage height in pixels. Default is full window.
         * @param {number} options.pace - The number of milliseconds to wait for each paced method.  Will disable pacing when set to zero.
         * @param {object} options.parent - The DOM element into which the stage will be inserted. Default is the body.
         * @param {object} options.backdrop - A default Backdrop.
         * @param {boolean} options.sensing - Enables sensing of mouse location and what keys pressed.
         * If true, will constantly update stage properties: mouseX, mouseY, keysKeyCode, keysKeyCode and keysCode based on user input.
         */
        constructor(options?: {
            width: number;
            height: number;
            pace: number;
            parent: object;
            backdrop: object;
            sensing: boolean;
        });
        backdrops: any[];
        backdrop: any;
        element: StageElement;
        width: number;
        height: number;
        keysCode: any[];
        keysKey: any[];
        keysKeyCode: any[];
        sprites: any[];
        magnification: number;
        cssRules: any[];
        classes: any[];
        mouseDown: any;
        mouseX: any;
        mouseY: any;
        /**
         * delete - Deletes the stage element.
         *
         * @example
         * let stage = new blockLike.Stage();
         *
         * stage.delete();
         */
        delete(): void;
        /**
         * addSprite - Adds a sprite to the stage
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * stage.addSprite(sprite);
         *
         * @param {object} sprite - the sprite to add.
         */
        addSprite(sprite: object): void;
        /**
         * removeSprite - Removes a sprite from the stage
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * stage.addSprite(sprite);
         * stage.removeSprite(sprite);
         *
         * @param {object} sprite - the sprite to add.
         */
        removeSprite(sprite: object): void;
        /**
         * addBackdrop - Adds a backdrop to the stage
         *
         * @example
         * let stage = new blockLike.Stage();
         * let backdrop = new blockLike.Backdrop();
         *
         * stage.addBackdrop(backdrop);
         *
         * @param {object} backdrop - the backdrop to add.
         */
        addBackdrop(backdrop: object): void;
        /**
         * switchBackdropTo - Switches to specified backdrop. If not found fails silently.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let backdrop = new blockLike.Backdrop();
         *
         * stage.addBackdrop(backdrop);
         * stage.switchBackdropTo(backdrop);
         *
         * @param {object} backdrop - the backdrop to switch too.
         */
        switchBackdropTo(backdrop: object): void;
        /**
         * switchBackdropToNum - Switches to specified backdrop by number of current (0 is first). If not found fails silently.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let backdrop = new blockLike.Backdrop();
         *
         * stage.addBackdrop(backdrop);
         * stage.switchBackdropToNum(1);
         *
         * @param {number} index - the backdrop to switch too.
         */
        switchBackdropToNum(index: number): void;
        /**
         * nextBackdrop - Switches to the next backdrop.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let backdrop = new blockLike.Backdrop();
         *
         * stage.addBackdrop(backdrop);
         * stage.nextBackdrop();
         */
        nextBackdrop(): void;
        /**
         * removeBackdrop - Removes a backdrop.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let backdrop = new blockLike.Backdrop();
         *
         * stage.addBackdrop(backdrop);
         * stage.removeBackdrop(backdrop);
         *
         * @param {object} backdrop - the backdrop to remove.
         */
        removeBackdrop(backdrop: object): void;
        /**
         * removeBackdropNum - Removes the specified backdrop by number of current (0 is first).
         * If there is only one backdrop, will fail and emit a console message.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let backdrop = new blockLike.Backdrop();
         *
         * stage.addBackdrop(backdrop);
         * stage.removeBackdropNum(1);
         *
         * @param {number} index - the backdrop to remove.
         */
        removeBackdropNum(index: number): void;
        /**
         * refresh - Forces a sprite refresh.
         * Note: service method to be used if costume was manipulated directly.
         */
        refresh(): void;
        /**
         * zoom - zooms the stage to the specified percentage number.
         *
         * @example
         * let stage = new blockLike.Stage();
         *
         * stage.zoom(150);
         *
         * @param {number} percent - the percentage to set.
         */
        zoom(percent: number): void;
        /**
         * sendSpriteBackwards - Moves the sprite one place down the "pile".
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * stage.addSprite(sprite);
         * stage.whenFlag( function() {
         *   this.sendSpriteBackwards(sprite);
         * });
         *
         * @param {object} sprite - the sprite to move.
         */
        sendSpriteBackwards(sprite: object): void;
        /**
         * sendSpriteForward - Moves the sprite one place up in the "pile".
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * stage.addSprite(sprite);
         * stage.whenFlag( function() {
         *   this.sendSpriteForward(sprite);
         * });
         *
         * @param {object} sprite - the sprite to move.
         */
        sendSpriteForward(sprite: object): void;
        /**
         * sendSpriteToFront - Brings the sprite to the front of the "pile"
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * stage.addSprite(sprite);
         * stage.whenFlag( function() {
         *   this.sendSpriteToFront(sprite);
         * });
         *
         * @param {object} sprite - the sprite to move.
         */
        sendSpriteToFront(sprite: object): void;
        /**
         * sendSpriteToBack - Sends the sprite to the back of the "pile"
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * stage.addSprite(sprite);
         * stage.whenFlag( function() {
         *   this.sendSpriteToBack(sprite);
         * });
         *
         * @param {object} sprite - the sprite to move.
         */
        sendSpriteToBack(sprite: object): void;
        /**
         * isKeyPressed - Checks if a key is pressed. Stage sensing must be enabled.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.say(stage.isKeyPressed('a'));
         *
         * @param {string} userKey - the key pressed. May be the code or the character itself (A or 65)
         * @param {function} func - a function to rewrite and execute.
         */
        isKeyPressed(userKey: string): boolean;
    }
    import Entity from "blocklike/entity";
    import StageElement from "blocklike/stage-element";
}

declare module 'blocklike/backdrop' {
    /**
      * Class representing a Backdrop.
      * Backdrops can be added to the Stage.
      * @extends Look
      *
      * @example
      * let backdrop = new blockLike.Backdrop();
      *
      * @example
      * let backdrop = new blockLike.Backdrop({
      *   image: 'https://www.blocklike.org/images/backdrop.svg'
      * });
      *
      * @example
      * let backdrop = new blockLike.Backdrop({
      *   color: '#A2DAFF'
      * });
      */
    export default class Backdrop extends Look {
        /**
         * constructor - Creates a Backdrop to be used by Stage objects.
         *
         * @param {object} options - options for the backdrop.
         * @param {string} options.image - a URI (or data URI) for the backdrop image.
         * @param {string} options.color - a css color string ('#ff0000', 'red')
         */
        constructor(options?: {
            image: string;
            color: string;
        });
        image: string;
        color: string;
        /**
         * addTo - Adds the backdrop to the stage
         *
         * @example
         * let stage = new blockLike.Stage();
         * let backdrop = new blockLike.Backdrop();
         *
         * backdrop.addTo(stage);
         *
         * @param {object} stage - which stage to add the backdrop too.
         */
        addTo(stage: object): void;
        /**
         * removeFrom - Removes the backdrop to the stage
         *
         * @example
         * let stage = new blockLike.Stage();
         * let backdrop = new blockLike.Backdrop();
         *
         * backdrop.addTo(stage);
         * backdrop.removeFrom(stage);
         *
         * @param {object} stage - which stage to remove the backdrop from.
         */
        removeFrom(stage: object): void;
    }
    import Look from "blocklike/look";
}

declare module 'blocklike/sprite' {
    /**
      * Class representing a Sprite.
      * Sprites can be added to the Stage.
      * @extends Entity
      *
      * @example
      * let sprite = new blockLike.Sprite();
      *
      * @example
      * let sprite = new blockLike.Sprite({
      *   costume: new blockLike.Costume({
      *     width: 50,
      *     height: 50,
      *     color: '#A2DAFF',
      *     image: 'https://www.blocklike.org/images/sheep_step.png'
      *   })
      * });
      *
      * @example
      * let sprite = new blockLike.Sprite({
      *     width: 50,
      *     height: 50,
      *     color: '#A2DAFF',
      *     image: 'https://www.blocklike.org/images/sheep_step.png'
      * });
      *
      * @example
      * let confetti = new blockLike.Sprite('https://www.blocklike.org/images/confetti.svg');
      *
      * @example
      * let bareZeroSizedSprite = new blockLike.Sprite(null);
      */
    export default class Sprite extends Entity {
        /**
         * constructor - Creates a Sprite to be added to Stage.
         *
         * @param {object} options - options for the sprite and/or options passed to costume.
         * Alternatively an image URL. If a URL is provided default costume will be sized to image.
         * @param {number} options.pace - The number of milliseconds to wait for each paced method.
         * @param {object} options.costume - A default Costume.
         * @param {number} options.width - the costume width in pixels. Default is 100.
         * @param {number} options.height - the costume height in pixels. Default is 100.
         * @param {string} options.image - a URL (or data URL) for the costume image.
         * @param {string} options.color - a css color string ('#ff0000', 'red').
         * @param {string} options - a URL (or data URL) for the costume image.
         */
        constructor(options?: {
            pace: number;
            costume: object;
            width: number;
            height: number;
            image: string;
            color: string;
        });
        costumes: any[];
        costume: any;
        width: any;
        height: any;
        x: number;
        y: number;
        z: number;
        prevX: number;
        prevY: number;
        showing: boolean;
        direction: number;
        magnification: number;
        rotationStyle: number;
        textui: any;
        drawing: boolean;
        penColor: string;
        penSize: number;
        cssRules: any[];
        classes: any[];
        /**
         * addTo - Adds the sprite to the stage
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         *
         * @param {object} stage - which stage to add the sprite too.
         */
        addTo(stage: object): void;
        stageWidth: any;
        stageHeight: any;
        element: any;
        surface: StageSurface;
        againstBackdrop: any;
        /**
         * clone - Creates a clone of the sprite and triggers an event.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *   let clone = this.clone();
         *   clone.move(100);
         *   clone.addTo(stage);
         * });
         *
         */
        clone(): Sprite;
        /**
         * removeFrom - Removes a sprite from the stage.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.removeFrom(stage);
         *
         */
        removeFrom(stage: any): void;
        /**
         * whenCloned - Adds a document level event listener triggered by a custom event.
         * The custom event is triggered by the clone() method.
         * When triggered will invoke user supplied function.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *   this.clone();
         * });
         *
         * sprite.whenCloned( function() {
         *   this.addTo(stage);
         *   this.glide(5, 100, 0);
         * });
         *
         * @param {function} func - a function to rewrite and execute.
         */
        whenCloned(func: Function): void;
        /**
         * glide - Moves the sprite for the specified number of seconds so it arrives at specified location when time is up.
         * Provides smooth movement.
         *
         * @example
         * sprite.whenClicked( function() {
         *   this.glide(3, 100, 100);
         * });
         *
         * @example
         * sprite.whenClicked( function() {
         *   let time = 5;
         *   this.glide(time, 100, 100);
         * });
         *
         * @param {number} sec - the number of seconds the whole movement will last (and will halt further execution for).
         * @param {number} x - the x coordinate.
         * @param {number} y - the y coordinate.
         */
        glide(sec: number, x: number, y: number, triggeringId?: any): void;
        /**
         * move - Moves the sprite a specified number of pixels in the direction it is pointing.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *   this.move(100, 100);
         * });
         *
         * @param {number} pixels - number of pixels to move.
         */
        move(pixels: number): void;
        /**
         * goTo - Moves the sprite to specified location.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *   this.goTo(100, 100);
         * });
         *
         * @param {number} x - the x coordinate.
         * @param {number} y - the y coordinate.
         */
        goTo(x: number, y: number): void;
        /**
         * goTowards - Moves the sprite towards another sprite.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         * let otherSprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * otherSprite.addTo(stage);
         * otherSprite.move(100);
         * sprite.whenClicked( function() {
         *   this.goTowards(otherSprite);
         * });
         *
         * @param {object} sprite - the sprite to move to.
         */
        goTowards(sprite: object): void;
        /**
         * setX - Places the sprite at the specified x position.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *   this.setX(100);
         * });
         *
         * @param {number} x - the x coordinate
         */
        setX(x: number): void;
        /**
         * setY - Places the sprite at the specified y position.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *   this.setY(100);
         * });
         *
         * @param {number} y - the y coordinate.
         */
        setY(y: number): void;
        /**
         * changeX - Moves the sprite on the x axis a specified number of pixels.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *   this.changeX(100);
         * });
         *
         * @param {number} pixels - number of pixels to move.
         */
        changeX(pixels: number): void;
        /**
         * changeY - Moves the sprite on the y axis a specified number of pixels.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *   this.changeY(100);
         * });
         *
         * @param {number} pixels - number of pixels to move.
         */
        changeY(pixels: number): void;
        /**
         * pointInDirection - Points the sprite in a specified direction.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *   this.pointInDirection(45);
         * });
         *
         * @param {number} deg - direction to point to.
         */
        pointInDirection(deg: number): void;
        /**
         * pointTowards - Point the sprite towards another sprite.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         * let otherSprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * otherSprite.addTo(stage);
         * otherSprite.goTo(100, 100);
         * sprite.whenClicked( function() {
         *   this.pointTowards(otherSprite);
         * });
         *
         * @param {object} sprite - the sprite to move to.
         */
        pointTowards(sprite: object): void;
        /**
         * turnRight - Turns the sprite in a specified number of degrees to the right (clockwise)
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *   this.turnRight(45);
         * });
         *
         * @param {number} deg - number of degrees to turn.
         */
        turnRight(deg: number): void;
        /**
         * turnLeft - Turns the sprite in a specified number of degrees to the left (counter-clockwise)
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *   this.turnLeft(45);
         * });
         *
         * @param {number} deg - number of degrees to turn.
         */
        turnLeft(deg: number): void;
        /**
         * setRotationStyle - Sets one of three possible rotation styles:
         *   - 'no' / 2 - the sprites changes the direction in which it points without changing the sprites appearance.
         *   - 'left-right' / 1 - the sprite will flip horizontally when direction is between 180 and 360.
         *   - 'all' / 0 - the sprite will rotate around its center
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.setRotationStyle('left-right');
         *
         * @example
         * sprite.setRotationStyle(1);
         *
         * @param {number} deg - number of degrees to turn.
         */
        setRotationStyle(style: any): void;
        /**
         * addCostume - Adds a costume to the sprite
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         * let costume = new blockLike.Costume();
         *
         * sprite.addTo(stage);
         * sprite.addCostume(costume);
         *
         * @param {object} costume - the costume to add.
         */
        addCostume(costume: object): void;
        /**
         * switchCostumeTo - Switches to specified costume. If not found fails silently.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         * let costume = new blockLike.Costume();
         *
         * sprite.addTo(stage);
         * sprite.addCostume(costume);
         * sprite.switchCostumeTo(costume);
         *
         * @param {object} backdrop - the costume to switch too.
         */
        switchCostumeTo(costume: any): void;
        /**
         * switchCostumeToNum - Switches to specified costume by number of current (0 is first). If not found fails silently.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         * let costume = new blockLike.Costume();
         *
         * sprite.addTo(stage);
         * sprite.addCostume(costume);
         * sprite.switchCostumeToNum(1);
         *
         * @param {number} index - the costume to switch too.
         */
        switchCostumeToNum(index: number): void;
        /**
         * nextCostume - Switches to the next costume.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         * let costume = new blockLike.Costume();
         *
         * sprite.addTo(stage);
         * sprite.addCostume(costume);
         * sprite.nextCostume();
         *
         */
        nextCostume(): void;
        /**
         * removeCostume - Removes a costume.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         * let costume = new blockLike.Costume();
         *
         * sprite.addTo(stage);
         * sprite.addCostume(costume);
         * sprite.removeCostume(costume);
         *
         * @param {object} costume - the costume to remove.
         */
        removeCostume(costume: object): void;
        /**
         * removeCostumeNum - Removes the specified costume by number of current (0 is first).
         * If there is only one costume, will fail and emit a console message.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         * let costume = new blockLike.Costume();
         *
         * sprite.addTo(stage);
         * sprite.addCostume(costume);
         * sprite.removeCostumeNum(1);
         *
         * @param {number} index - the costume to remove.
         */
        removeCostumeNum(index: number): void;
        /**
         * show - Shows the sprite. By default sprites are shown.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.hide();
         * sprite.show();
         *
         */
        show(): void;
        /**
         * hide - Hides the sprite. By default sprites are shown.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.hide();
         *
         */
        hide(): void;
        /**
         * refresh - Forces a sprite refresh.
         * Note: service method to be used if costume was manipulated directly.
         */
        refresh(): void;
        /**
         * resizeToImage - sets the width and height of the sprite to that of the image file of current costume.
         * Note: service method. Similar to calling resizeToImage() on costume and then refresh() on sprite.
         *
         * @example
         * const sprite = new blockLike.Sprite(null);
         *
         * const angrySheep = new blockLike.Costume({
         *   image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/d/db/Emojione_1F411.svg/200px-Emojione_1F411.svg.png',
         * });
         * angrySheep.addTo(sprite);
         *
         * sprite.resizeToImage();
         * sprite.addTo(stage);
         */
        resizeToImage(): void;
        /**
         * inner - Places an HTML element inside the current costume of the sprite.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.inner('<p class="big centered rainbow">:)</p>');
         *
         * @example
         * sprite.inner('I like text only');
         *
         * @param {object} el - the DOM element.
         */
        inner(html: any): void;
        /**
         * insert - Places a DOM element inside the current costume of the sprite.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.insert(document.getElementById('my-html-creation'));
         *
         * @param {object} el - the DOM element.
         */
        insert(el: object): void;
        /**
         * changeSize - Changes the size of the sprite by specified percentage number.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.changeSize(50);
         *
         * @param {number} change - the percentage change.
         */
        changeSize(change: number): void;
        /**
         * setSize - Sets the size of the sprite to the specified percentage number.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.setSize(150);
         *
         * @param {number} percent - the percentage to set.
         */
        setSize(percent: number): void;
        /**
         * think - Creates a "think bubble" over the sprite.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.think('I think therefore I am.');
         *
         * @param {string} text - the text inside the bubble.
         */
        think(text: string): void;
        /**
         * thinkWait - Creates a "think bubble" over the sprite for a specified number of seconds.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.thinkWait('I think therefore I am.', 3);
         *
         * @param {string} text - the text inside the bubble.
         * @param {number} sec - the number of seconds to wait.
         */
        thinkWait(text: string, sec: number, triggeringId?: any): void;
        /**
         * say - Creates a "speech bubble" over the sprite.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.say('It is not the consciousness of men that determines their being, but, on the contrary, their social being that determines their consciousness.');
         *
         * @param {string} text - the text inside the bubble.
         */
        say(text: string): void;
        /**
         * sayWait - Creates a "speech bubble" over the sprite for a specified number of seconds.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.sayWait('It is not the consciousness of men that determines their being, but, on the contrary, their social being that determines their consciousness.', 3);
         *
         * @param {string} text - the text inside the bubble.
         * @param {number} sec - the number of seconds to wait.
         */
        sayWait(text: string, sec: number, triggeringId?: any): void;
        /**
         * ask - Creates an "ask bubble" over the sprite.
         * Allows for an input box to be displayed to the user and
         * capture user input into the variable specified by the user.
         * Note - variable for answer must be declared in global scope.
         *
         * @example
         * //good:
         * let answer;
         * sprite.whenClicked( function() {
         *   answer = this.ask('Is the destiny of mankind decided by material computation?');
         *   this.say(answer);
         * });
         *
         * // bad:
         * sprite.whenClicked( function() {
         *   let answer;
         *   answer = this.ask('Is the destiny of mankind decided by material computation?');
         *   this.say(answer);
         * });
         *
         * @param {string} text - the text of the question
         *
         */
        ask(text: string, theVar?: any, triggeringId?: any): void;
        askId: string;
        /**
         * penClear - Clears the drawing surface.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *   this.penClear();
         * });
         *
         */
        penClear(): void;
        /**
         * penDown - "Activates" drawing by setting required values.
         * When activated sprite motion will create the drawing on the stage's canvas.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *   this.penDown();
         *   this.move(100);
         * });
         *
         */
        penDown(): void;
        /**
         * penUp - "Deactivates" drawing by setting required values.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *   this.penDown();
         *   this.move(100);
         *   this.penUp();
         * });
         *
         */
        penUp(): void;
        /**
         * setPenColor - Sets the color of the pen.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.setPenColor('#ff0000')
         *
         * @example
         * sprite.setPenColor('red')
         *
         * @param {string} colorString - a valid color definition for canvas strokeStyle.
         */
        setPenColor(colorString: string): void;
        /**
         * setPenSize - Sets the size of the pen.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.setPenSize(10);
         *
         * @param {number} pixels - a number for canvas lineWidth.
         */
        setPenSize(pixels: number): void;
        /**
         * changePenSize - Changes the size of the pen.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *   this.changePenSize(10);
         * });
         *
         * @param {number} change - the change in pixels.
         */
        changePenSize(change: number): void;
        /**
         * distanceTo - Returns the distance to a point on the screen.
         *
         * @example
         * let stage = new blockLike.Stage({sensing: true});
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         *
         * stage.whenClicked( function() {
         *  sprite.say(this.distanceTo(this.mouseX, this.mouseY))
         * });
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         * let sprite = new blockLike.otherSprite();
         *
         * sprite.addTo(stage);
         * otherSprite.addTo(stage);
         *
         * stage.whenClicked( function() {
         *  sprite.say(this.distanceTo(otherSprite.x, otherSprite.y))
         * });
         *
         * @param {number} x - the x coordinate.
         * @param {number} y - the y coordinate.
         * @return {number} - distance in pixels to position on screen (not rounded).
         */
        distanceTo(x: number, y: number): number;
        /**
         * touchingEdge - Checks is this sprite touches the edge of the stage and returns the edge touched.
         *
         * Notes:
         * 1. This is based on rectangular collision detection.
         * 2. this compares a naive rectangle, so if the sprite is rotated touching might be sensed early or late.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *  while(this.x < stage.width / 2) {
         *    this.move(10)
         *    this.say(this.touchingEdge());
         *   }
         * });
         *
         * @return {string} - the side of the stage that is touched (null, top, bottom, left, right)
         */
        touchingEdge(): string;
        /**
         * isTouchingEdge - Checks is this sprite touches the edge.
         *
         * Notes:
         * 1. This is based on rectangular collision detection.
         * 2. this compares a naive rectangle, so if the sprite is rotated touching might be sensed early or late.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *  while(this.x < stage.width / 2) {
         *    this.move(10)
         *    this.say(this.isTouchingEdge());
         *   }
         * });
         *
         * @return {boolean} - is the sprite touching the edge.
         */
        isTouchingEdge(): boolean;
        /**
         * touching - Checks is this sprite touches another and returns at what side it touches.
         *
         * Notes:
         * 1. this compares a naive rectangle, so if the sprite is rotated touching might be sensed early or late.
         * 2. if the sprite has gone "into" the other the side "penetrated more" will be returned.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         * let otherSprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * otherSprite.addTo(stage);
         * otherSprite.move(200);
         * sprite.whenClicked( function() {
         *  while(!this.touching(otherSprite)) {
         *    this.move(10);
         *    this.say(this.touching(otherSprite))
         *   }
         * });
         *
         * @param {string} sprite - the sprite to check if touching.
         * @return {string} - the side of the sprite that is touched (null, top, bottom, left, right)
         */
        touching(sprite: string): string;
        /**
         * isTouching - Checks is this sprite touches another.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         * let otherSprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * otherSprite.addTo(stage);
         * otherSprite.move(200);
         * sprite.whenClicked( function() {
         *  while(!this.isTouching(otherSprite)) {
         *    this.move(10);
         *   }
         * });
         *
         * @param {string} sprite - the sprite to check if touching.
         * @return {boolean} - is the sprite touching the specified sprite.
         */
        isTouching(sprite: string): boolean;
        /**
         * touchingBackdropColor - Returns the hex value to all pixels in backdrop area covered by the sprite rectangle.
         *
         * Notes:
         * 1. This is based on rectangular collision detection.
         * 2. This compares a naive rectangle, so if the sprite is rotated touching might be sensed early or late.
         * 3. The backdrop image must be a local image served from same origin.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *   while(true){
         *     let touchedColors = this.touchingBackdropColor();
         *     this.say(touchedColors);
         *     this.move(5);
         *   }
         * });
         *
         * @return {array} - colors (strings) touched.
         */
        touchingBackdropColor(): any[];
        /**
         * isTouchingBackdropColor - compares a given hex value to all pixels in backdrop area covered by the sprite rectangle.
         * If a match is found the color is returned.
         *
         * Notes:
         * 1. This is based on rectangular collision detection.
         * 2. This compares a naive rectangle, so if the sprite is rotated touching might be sensed early or late.
         * 3. The backdrop image must be a local image served from same origin.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * let moving = true;
         * sprite.whenClicked( function() {
         *   while(moving){
         *     this.isTouchingBackdropColor('#ff0000') ? moving = false : moving = true;
         *     this.move(5);
         *   }
         * });
         *
         * @param {string} backdropColor - the color to evaluate.
         * @return {boolean} - does the sprite touch the color.
         */
        isTouchingBackdropColor(backdropColor: string): boolean;
    }
    import Entity from "blocklike/entity";
    import StageSurface from "blocklike/stage-surface";
}

declare module 'blocklike/costume' {
    /**
      * Class representing a Costume.
      * Costumes can be added to a Sprite.
      * @extends Look
      *
      * @example
      * let costume = new blockLike.Costume();
      *
      * @example
      * let costume = new blockLike.Costume({
      *   width: 50,
      *   height: 50,
      *   color: '#A2DAFF',
      *   image: 'https://www.blocklike.org/images/sheep_step.png'
      * });
      */
    export default class Costume extends Look {
        /**
         * constructor - Creates a Costume to be used by Sprite objects..
         *
         * @param {object} options - options for the costume.
         * @param {number} options.width - the costume width in pixels. Default is 100.
         * @param {number} options.height - the costume height in pixels. Default is 100.
         * @param {string} options.image - a URI (or data URI) for the costume image.
         * @param {string} options.color - a css color string ('#ff0000', 'red')
         */
        constructor(options?: {
            width: number;
            height: number;
            image: string;
            color: string;
        });
        width: number;
        height: number;
        visibleWidth: number;
        visibleHeight: number;
        image: string;
        color: string;
        innerHTML: string;
        /**
         * addTo - Adds the costume to the sprite
         *
         * @example
         * let sprite = new blockLike.Sprite();
         * let costume = new blockLike.Costume();
         *
         * costume.addTo(sprite);
         *
         * @param {object} sprite - which sprite to add the costume too.
         */
        addTo(sprite: object): void;
        /**
         * removeFrom - Removes the costume from to the sprite
         *
         * @example
         * let sprite = new blockLike.Sprite();
         * let costume = new blockLike.Costume();
         *
         * costume.addTo(sprite);
         * costume.removeFrom(sprite);
         *
         * @param {object} sprite - which sprite to remove the costume from.
         */
        removeFrom(sprite: object): void;
        /**
         * resizeToImage - sets the width and height of the costume to that of the image file.
         *
         * @example
         * let costume = new blockLike.Costume({
         *   image: 'https://upload.wikimedia.org/wikipedia/commons/d/d3/Sheep_in_gray.svg'
         * });
         *
         * costume.resizeToImage();
         */
        resizeToImage(): void;
        /**
         * inner - Places an HTML element inside the costume.
         *
         * @example
         * let costume = new blockLike.Costume();
         *
         * costume.inner('<p class="big centered rainbow">:)</p>');
         *
         * @example
         * costume.inner('I like text only');
         *
         * @param {string} html - the html to insert.
         */
        inner(html: string): void;
        /**
         * insert - Places a DOM element inside the costume.
         *
         * @example
         * let costume = new blockLike.Costume();
         *
         * costume.insert(document.getElementById('my-html-creation'));
         *
         * @param {object} el - the DOM element.
         */
        insert(el: object): void;
    }
    import Look from "blocklike/look";
}

declare module 'blocklike/entity' {
    /**
      * Class representing an entity.
      * Abstract for Stage and Sprite.
      * Do not instantiate objects directly from this class.
      *
      * @private
      */
    export default class Entity {
        /**
         * constructor - Entity is abstract for Stage and Sprite.
         *
         * @param {number} pace - the number of milliseconds to pace paced methods.
         */
        constructor(pace: number);
        id: string;
        pace: number;
        sounds: any[];
        paced: string[];
        waited: string[];
        waitedReturned: string[];
        evented: string[];
        triggeringId: string;
        /**
         * invoke - invoke a function. Allows passing an argument or array of arguments.
         * Function will be "paced" and code execution will be "waited" until it is completed.
         *
         * @example
         * sprite.whenFlag(() => {
         *   this.invoke(jump);
         *   this.invoke(talk, 'hi');
         *   this.invoke(pattern, [5, 50, 12]);
         * });
         *
         * @param {function} func - a function to rewrite and execute.
         * @param {array} argsArr - an array of arguments to pass to the function. A single variable also accepted.
         */
        invoke(func: Function, argsArr: any[], theVar?: any, triggeringId?: any): void;
        /**
         * wait - creates a pause in execution.
         *
         * @example
         * this.wait(5);
         *
         * @example
         * let time = 5;
         * this.wait(time * 0.95);
         *
         * @param {number} sec - number of seconds to wait. Must be an actual number.
         */
        wait(sec: number, triggeringId?: any): void;
        /**
         * whenLoaded - invoke user supplied function.
         * To be used with code that needs to run onload.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenLoaded( function() {
         *   this.say('I am alive');
         * });
         *
         * @param {function} func - a function to rewrite and execute.
         */
        whenLoaded(func: Function): void;
        /**
         * whenFlag - adds a flag to cover the stage with an event listener attached.
         * When triggered will remove the flag div and invoke user supplied function.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenFlag( function() {
         *   this.say('I am alive');
         * });
         *
         * @param {function} func - a function to rewrite and execute.
         */
        whenFlag(func: Function): void;
        /**
         * whenClicked - adds a click event listener to the sprite or stage.
         * When triggered will invoke user supplied function.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *   this.say('I am alive');
         * });
         *
         * @param {function} func - a function to rewrite and execute.
         */
        whenClicked(func: Function): void;
        /**
         * whenKeyPressed - adds a keypress event listener to document.
         * When triggered will invoke user supplied function.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenKeyPressed(' ', function() {
         *   this.say('Spacepressed');
         * });
         *
         * @param {string} userKey - the key pressed. may be the code or the character itself (A or 65)
         * @param {function} func - a function to rewrite and execute.
         */
        whenKeyPressed(userKey: string, func: Function): void;
        /**
         * whenEvent - adds the specified event listener to sprite/stage.
         * When triggered will invoke user supplied function.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenEvent('mouseover', (e) => {
         *   console.log(e);
         * });
         *
         * @param {string} eventStr - the named event (mosemove etc.).
         * @param {function} func - a function to rewrite and execute.
         */
        whenEvent(eventStr: string, func: Function): void;
        /**
         * whenReceiveMessage - adds the specified event listener to document.
         * When triggered will invoke user supplied function.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenReceiveMessage('move', function() {
         *   this.move(-10);
         * })
         *
         * @param {string} msg - the named message (event);
         * @param {function} func - a function to rewrite and execute.
         */
        whenReceiveMessage(msg: string, func: Function): void;
        /**
         * broadcastMessage - dispatches a custom event that acts as a global message.
         *
         * @example
         * let stage = new blockLike.Stage();
         *
         * stage.whenClicked(function() {
         *  stage.broadcastMessage('move')
         * });
         *
         * @param {string} msg - the named message (event)
         */
        broadcastMessage(msg: string): void;
        /**
         * broadcastMessageWait - dispatches a custom event that acts as a global message.
         * Waits for all whenReceiveMessage listeners to complete.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         *
         * sprite.whenReceiveMessage('move', function() {
         *   this.move(-10);
         *   this.wait(5);
         * })
         *
         * stage.whenClicked(function() {
         *  stage.broadcastMessageWait('move');
         *  sprite.say('All done');
         * });
         *
         * @param {string} msg - the named message (event)
         */
        broadcastMessageWait(msg: string, triggeringId?: any): void;
        /**
         * playSound - plays a sound file (mp3, wav)
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *   this.playSound('../../sounds/bleat.wav');
         * });
         *
         * @param {string} url - the url of the file to play.
         */
        playSound(url: string): void;
        /**
         * playSoundLoop - plays a sound file (mp3, wav) again and again
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *   this.playSoundLoop('../../sounds/bleat.wav');
         * });
         *
         * @param {string} url - the url of the file to play.
         */
        playSoundLoop(url: string): void;
        /**
         * playSoundUntilDone - plays a sound file (mp3, wav) until done.
         * This is similar to playSound and wait for the duration of the sound.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *   this.playSoundUntilDone('../../sounds/bleat.wav');
         * });
         *
         * @param {string} url - the url of the file to play.
         */
        playSoundUntilDone(url: string, triggeringId?: any): void;
        /**
         * stopSounds - stops all sounds played by sprite or stage.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *   this.playSound('../../sounds/bleat.wav');
         * });
         *
         * stage.whenKeyPressed('Escape', () => {
         *   this.stopSounds();
         * });
         */
        stopSounds(): void;
        /**
         * css - applies a CSS rule to the sprite and all costumes.
         *
         * @example
         * let sprite = new blockLike.Sprite();
         *
         * sprite.css('background', '#0000ff');
         *
         * @param {string} prop - the css property (e.g. color). Alternatively an object with key: value pairs.
         * @param {string} value - the value for the css property (e.g. #ff8833)
         */
        css(prop: string, value?: string): void;
        /**
         * addClass - adds a css class to sprite and all costumes.
         *
         * @example
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addClass('rainbow');
         *
         * @param {string} name - the css class name to add.
         */
        addClass(name: string): void;
        /**
         * removeClass - removes a css class from the sprite and all costumes.
         *
         * @example
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addClass('rainbow');
         * sprite.removeClass('rainbow');
         *
         * @param {string} name - the css class name to remove.
         */
        removeClass(name: string): void;
        classes: any;
        /**
         * hasClass - is the css class applied to the sprite and all costumes.
         *
         * @example
         * let stage = new blockLike.Stage();
         * let sprite = new blockLike.Sprite();
         *
         * sprite.addTo(stage);
         * sprite.whenClicked( function() {
         *   this.hasClass('rainbow') ? this.removeClass('rainbow') : this.addClass('rainbow');
         * });
         *
         * @param {string} name - the css class name.
         * @return {boolean} - is the css class name on the list.
         */
        hasClass(name: string): boolean;
    }
}

declare module 'blocklike/stage-element' {
    /**
      * Class representing the UI Element of the stage.
      * Each Stage has one.
      * @private
      */
    export default class StageElement {
        /**
         * constructor - Creates a Stage Element.
         *
         * @param {object} options - the stage for which the element is created.
         * @param {object} stage - the stage created.
         */
        constructor(options: object, stage: object);
        backdropContainer: any;
        canvas: any;
        flag: any;
        context: any;
        el: HTMLDivElement;
        /**
         * update - updates the DOM element.
         *
         * @param {object} stage - the stage to update.
         */
        update(stage: object): void;
        /**
         * delete - deletes the DOM element
         */
        delete(stage: any): any;
        /**
         * addFlag - puts the flag div infront of everything (shows it)
         *
         * @param {object} stage - the stage that "requested" the flag.
         */
        addFlag(stage: object): void;
        /**
         * removeFlag - puts the flag div at the back (hides it)
         *
         * @param {object} stage - the stage that "requested" the flag.
         */
        removeFlag(stage: object): void;
    }
}

declare module 'blocklike/look' {
    /**
      * Class representing a look.
      * Abstract for Costume and Backdrop.
      * Do not instantiate objects directly from this class.
      *
      * @private
      */
    export default class Look {
        cssRules: any[];
        classes: any[];
        /**
         * css - applies a CSS rule to a Costume or Backdrop.
         *
         * @example
         * let costume = new blockLike.Costume();
         *
         * costume.css('font-size', '16px');
         *
         * @example
         * let backdrop = new blockLike.Backdrop();
         *
         * backdrop.css('cursor', 'pointer');
         *
         * @param {string} prop - the css property (e.g. color)
         * @param {string} value - the value for the css property (e.g. #ff8833)
         */
        css(prop: string, value?: string): void;
        /**
         * addClass - adds a css class to costume.
         *
         * @example
         * let costume = new blockLike.Costume();
         *
         * costume.addClass('rainbow');
         *
         * @example
         * let backdrop = new blockLike.Backdrop();
         *
         * backdrop.addClass('rainbow');
         *
         * @param {string} name - the css class name to add.
         */
        addClass(name: string): void;
        /**
         * removeClass - removes a css class from the costume.
         *
         * @example
         * let costume = new blockLike.Costume();
         *
         * costume.hasClass('rainbow') ? costume.removeClass('rainbow') : costume.addClass('rainbow');
         *
         * @example
         * let backdrop = new blockLike.Backdrop();
         *
         * backdrop.hasClass('rainbow') ? backdrop.removeClass('rainbow') : backdrop.addClass('rainbow');
         *
         * @param {string} name - the css class name to remove.
         */
        removeClass(name: string): void;
        /**
         * hasClass - is the css class applied to the costume.
         *
         * @example
         * let costume = new blockLike.Costume();
         *
         * costume.hasClass('rainbow') ? costume.removeClass('rainbow') : costume.addClass('rainbow');
         *
         * @example
         * let backdrop = new blockLike.Backdrop();
         *
         * backdrop.hasClass('rainbow') ? backdrop.removeClass('rainbow') : backdrop.addClass('rainbow');
         *
         * @param {string} name - the css class name.
         * @return {boolean} - is the css class name on the list.
         */
        hasClass(name: string): boolean;
    }
}

declare module 'blocklike/stage-surface' {
    /**
      * Class representing the stage surface on which sprites draw.
      * Each Stage has one.
      * @private
      */
    export default class StageSurface {
        /**
         * constructor - Creates a Stage.
         *
         * @param {object} stage - the stage on which the sprite is drawing.
         */
        constructor(stage: object);
        context: any;
        /**
         * draw - draws a line "behind" a moving sprite.
         * Note: sprite always has current and previous x,y values to allow drawing to previous location.
         *
         * @param {object} sprite - the sprite drawing the line.
         */
        draw(sprite: object): void;
        /**
         * clear - clears the canvas
         */
        clear(sprite: any): void;
    }
}

